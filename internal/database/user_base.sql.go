// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user_base.sql

package database

import (
	"context"
	"database/sql"
)

const addUserInfoBase = `-- name: AddUserInfoBase :one
INSERT INTO user_base (
  user_account, user_password, user_salt, user_login_time, user_logout_time, user_login_ip, user_created_at, user_updated_at
) VALUES (
  $1, $2, $3, NULL, NULL, NULL, NOW(), NOW()
)
RETURNING user_id, user_account, user_password, user_salt, user_login_time, user_logout_time, user_login_ip, user_created_at, user_updated_at
`

type AddUserInfoBaseParams struct {
	UserAccount  string
	UserPassword string
	UserSalt     string
}

func (q *Queries) AddUserInfoBase(ctx context.Context, arg AddUserInfoBaseParams) (UserBase, error) {
	row := q.db.QueryRowContext(ctx, addUserInfoBase, arg.UserAccount, arg.UserPassword, arg.UserSalt)
	var i UserBase
	err := row.Scan(
		&i.UserID,
		&i.UserAccount,
		&i.UserPassword,
		&i.UserSalt,
		&i.UserLoginTime,
		&i.UserLogoutTime,
		&i.UserLoginIp,
		&i.UserCreatedAt,
		&i.UserUpdatedAt,
	)
	return i, err
}

const changePasswordUserBase = `-- name: ChangePasswordUserBase :exec
UPDATE user_base
SET 
  user_password = $2,
  user_updated_at = NOW()
WHERE user_id = $1
`

type ChangePasswordUserBaseParams struct {
	UserID       int32
	UserPassword string
}

func (q *Queries) ChangePasswordUserBase(ctx context.Context, arg ChangePasswordUserBaseParams) error {
	_, err := q.db.ExecContext(ctx, changePasswordUserBase, arg.UserID, arg.UserPassword)
	return err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT user_id, user_account, user_password, user_salt, user_login_time, user_logout_time, user_login_ip, user_created_at, user_updated_at
FROM user_base
WHERE user_account = $1
`

func (q *Queries) FindUserByEmail(ctx context.Context, userAccount string) (UserBase, error) {
	row := q.db.QueryRowContext(ctx, findUserByEmail, userAccount)
	var i UserBase
	err := row.Scan(
		&i.UserID,
		&i.UserAccount,
		&i.UserPassword,
		&i.UserSalt,
		&i.UserLoginTime,
		&i.UserLogoutTime,
		&i.UserLoginIp,
		&i.UserCreatedAt,
		&i.UserUpdatedAt,
	)
	return i, err
}

const findUserByIdBase = `-- name: FindUserByIdBase :one
SELECT user_id, user_account, user_password, user_salt, user_login_time, user_logout_time, user_login_ip, user_created_at, user_updated_at
FROM user_base
WHERE user_id = $1
`

func (q *Queries) FindUserByIdBase(ctx context.Context, userID int32) (UserBase, error) {
	row := q.db.QueryRowContext(ctx, findUserByIdBase, userID)
	var i UserBase
	err := row.Scan(
		&i.UserID,
		&i.UserAccount,
		&i.UserPassword,
		&i.UserSalt,
		&i.UserLoginTime,
		&i.UserLogoutTime,
		&i.UserLoginIp,
		&i.UserCreatedAt,
		&i.UserUpdatedAt,
	)
	return i, err
}

const updateUserInfoBase = `-- name: UpdateUserInfoBase :exec
UPDATE user_base
SET 
  user_salt = $2,
  user_login_time = $3,
  user_logout_time = $4,
  user_login_ip = $5,
  user_updated_at = NOW()
WHERE user_id = $1
`

type UpdateUserInfoBaseParams struct {
	UserID         int32
	UserSalt       string
	UserLoginTime  sql.NullTime
	UserLogoutTime sql.NullTime
	UserLoginIp    sql.NullString
}

func (q *Queries) UpdateUserInfoBase(ctx context.Context, arg UpdateUserInfoBaseParams) error {
	_, err := q.db.ExecContext(ctx, updateUserInfoBase,
		arg.UserID,
		arg.UserSalt,
		arg.UserLoginTime,
		arg.UserLogoutTime,
		arg.UserLoginIp,
	)
	return err
}
